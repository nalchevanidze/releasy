# Relasy

Relasy is a set of GitHub Actions for **label-driven releases**. It automates the full flow:

- determine the **next version** from PR labels
- generate a **changelog** from merged PRs since the last release
- open a **release PR** containing both the changelog and the version bump commit
- publish a **GitHub Release** when that release PR is merged
- validate and bootstrap PR labels to keep changelogs clean

> **Source of truth:** the **release PR** generated by `draft-release`.

---

## How it works (Draft â†’ Release PR â†’ Publish)

### 1) Draft release (`draft-release` action)

Triggered manually (usually via `workflow_dispatch`).

`draft-release` will:

- collect merged PRs since the last GitHub Release (or tag)
- compute the **next version** using PR labels (semver bump rules)
- update version files (based on your config), and **commit** the version bump
- generate a changelog grouped by labels (and optionally by package scope)
- open a **release PR** to `main`:
  - **title:** `release-<version>`
  - **body:** generated changelog
  - **commits:** includes the version bump commit generated by the action

âœ… You **do not** need to bump versions manually.

### 2) Review the release PR

Before merging, you can optionally edit the PR body to:

- polish wording
- reorder sections
- remove internal notes, etc.
- commit additional changes if needed (manual fixes, etc.)

### 3) Publish release (`publish-release` action)

Triggered when the release PR is merged.

`publish-release` will:

- detect merged PRs where:
  - base branch is `main`
  - head branch starts with `release-`
- use the **merged release PR body** as the release notes
- create/publish the **GitHub Release** (optionally returning an `upload_url` output)

---

## Labels drive versioning & changelogs

Relasy uses PR labels to decide:

- **what bump** a change represents (major/minor/patch)
- **where it appears** in the changelog (Breaking / Features / Fixes / etc.)
- optional **scope** (package/module grouping for monorepos)

Typical mapping:

- `ğŸš¨ major` â†’ **major**
- `âœ¨ feature` â†’ **minor**
- `ğŸ› fix`, `ğŸ§¹ chore` â†’ **patch**
- `ğŸ“¦ <name>` â†’ scope/grouping in changelog for monorepos

When multiple PRs are included in a release, Relasy applies the **highest bump** needed across them (major > minor > patch).

---

## Configuration (`relasy.json`)

Relasy reads configuration from `relasy.json` to adapt to your repo conventions without changing action code.

At a high level, `relasy.json` describes:

- the **pkgs** in your repo (single package or many packages/modules)
- which **tooling** is used to resolve versioning/publishing details (`project`)

### Schema overview

```json
{
  "pkgs": {
    "shortName": "long-package-identifier"
  },
  "project": {
    "type": "npm"
  }
}
```

### `pkgs`

`pkgs` is a mapping of logical **pkg keys** to a **package identifier**.

- For **npm** projects, the value is typically the npm package name (often scoped).
- For **custom** projects, the value is whatever identifier the custom workflow expects.

The `pkgs` keys (`core`, `server`, `client`, etc.) are the handles you reference when you need to act on a specific module/package.

You can override any subset by providing only those keys.

### `project`

`project` selects the manager used by Relasy.

Supported managers:

- `type: "npm"`
- `type: "custom"`

If `type` is `"custom"`, the following fields are required:

- `pkg` (string): a package reference or URL template (can include `{{SCOPE}}`)
- `version` (string): command to retrieve the current version
- `next` (string): command to compute the next version
- `setup` (string): command to prepare tooling/environment

---

## Configuration examples

### npm project (single scope)

```json
{
  "pkgs": {
    "core": "relasy/core"
  },
  "project": {
    "type": "npm"
  }
}
```

### custom project (multi-scope)

```json
{
  "pkgs": {
    "server": "morpheus-graphql",
    "client": "morpheus-graphql-client",
    "core": "morpheus-graphql-core",
    "subscriptions": "morpheus-graphql-subscriptions",
    "tests": "morpheus-graphql-tests",
    "app": "morpheus-graphql-app",
    "codegen": "morpheus-graphql-code-gen"
  },
  "project": {
    "type": "custom",
    "pkg": "https://hackage.haskell.org/package/{{PKG}}",
    "version": "hconf version",
    "next": "hconf next",
    "setup": "hconf setup 9.6.3"
  }
}
```

**Notes:**

- In custom mode, `{{SCOPE}}` is substituted with the resolved scope identifier
  (e.g. `morpheus-graphql-core`).

---

## Publishing strategies

### `npm` (simple, centralized version)

When `project.type` is `"npm"`:

- versioning is typically **centralized** (e.g. one version source of truth)
- best suited when packages share a version

âœ… easiest to operate
âš ï¸ not suitable if each package needs independent versions

### `custom` (fully flexible)

When `project.type` is `"custom"`:

- use it when you need custom versioning rules or publishing commands

âœ… best for complex repos / bespoke pipelines

---

## Example: generated changelog (release PR body)

Example output (placeholders only):

```md
## 1.4.0 (2026-01-14)

#### Breaking Changes

- [#123](https://github.com/acme/awesome-monorepo/pull/123): Remove legacy auth middleware
  - ğŸ“¦ server
  - ğŸ‘¤ @contributor-1

#### New features

- [#141](https://github.com/acme/awesome-monorepo/pull/141): Add caching for search endpoint
  - ğŸ“¦ server
  - ğŸ‘¤ @contributor-2
- [#155](https://github.com/acme/awesome-monorepo/pull/155): Add dark mode toggle
  - ğŸ“¦ client
  - ğŸ‘¤ @contributor-3

#### Bug Fixes

- [#160](https://github.com/acme/awesome-monorepo/pull/160): Fix pagination edge case for empty results
  - ğŸ“¦ client
  - ğŸ‘¤ @contributor-4

#### Minor Changes

- [#166](https://github.com/acme/awesome-monorepo/pull/166): Update local dev docs
  - ğŸ“¦ docs
  - ğŸ‘¤ @contributor-5
```

---

## Workflow templates

### Draft Release (manual)

Creates the release PR (version + changelog + commits).

```yaml
name: Draft Release
on: workflow_dispatch

permissions:
  contents: write
  pull-requests: write

jobs:
  draft-release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Draft Release PR (compute version + commit bump + changelog + open PR)
        uses: nalchevanidze/relasy/actions/draft-release@0.2.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### Publish Release (on merge of release PR)

Publishes GitHub Release from the merged release PR.

```yaml
name: Publish Release
on:
  pull_request:
    types: [closed]

permissions:
  contents: write

jobs:
  publish_release:
    if: ${{ github.base_ref == 'main' && startsWith(github.head_ref, 'release-') && github.event.pull_request.merged == true }}
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.publish.outputs.upload_url }}
    steps:
      - uses: actions/checkout@v4

      - name: Publish GitHub Release (from merged release PR)
        uses: nalchevanidze/relasy/actions/publish-release@0.2.1
        id: publish
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

---

## Recommended labeling rules

To keep changelogs predictable, it helps if each PR has:

- **exactly one** â€œtypeâ€ label (breaking/feature/fix/etc.)
- optional scope labels for monorepos (`ğŸ“¦ <name>`)

Example labels:

- change/type(version bump):
  - `ğŸš¨ major`
  - `ğŸ’¥ breaking`
  - `âœ¨ feature`
  - `ğŸ› fix`
  - `ğŸ§¹ chore`
- scope (packages/modules):
  - `ğŸ“¦ client`
  - `ğŸ“¦ server`
  - `ğŸ“¦ docs`

Relasy may also include helper actions to:

- bootstrap/standardize labels
- validate that PR labels are allowed (so changelog generation stays clean)

## Helper Actions (recommended)

Relasy works best when PR labels are consistent. To make that easy, add these optional helper actions to your workflows.

### Validate PR labels (`validate-pr-labels`)

This action enforces the â€œlabel contractâ€ on every PR so releases donâ€™t get blocked or produce messy changelogs.

What it checks (recommended defaults):

- **Exactly one** change/type label (e.g. `ğŸš¨ major`, `ğŸ’¥ breaking`, `âœ¨ feature`, `ğŸ› fix`, `ğŸ§¹ chore`)
- **Zero or one** scope label for monorepos (e.g. `ğŸ“¦ client`, `ğŸ“¦ server`)
- If a scope label is present, it must match a key in `relasy.json` â†’ `scope` (prevents typos like `ğŸ“¦ frontend`)

Suggested workflow:

```yaml
name: Validate PR Labels

on:
  pull_request:
    types:
      [
        opened,
        reopened,
        labeled,
        unlabeled,
        synchronize,
        edited,
        ready_for_review,
      ]

permissions:
  contents: read
  pull-requests: read

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate PR Labels
        uses: nalchevanidze/relasy/actions/validate-pr-labels@main
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

---

### Bootstrap labels (`bootstrap-labels`)

This action creates the labels Relasy expects in a repository (useful for onboarding and keeping label sets consistent).

What it creates (typical):

- Type labels: `ğŸš¨ major`, `ğŸ’¥ breaking`, `âœ¨ feature`, `ğŸ› fix`, `ğŸ§¹ chore`
- Scope labels from `relasy.json`: `ğŸ“¦ <scopeKey>` for each key under `scope`

Suggested workflow:

```yaml
name: Bootstrap Labels
on: workflow_dispatch

permissions:
  contents: read
  issues: write

jobs:
  bootstrap:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create/ensure required labels exist
        uses: nalchevanidze/relasy/actions/bootstrap-labels@0.2.1
```

## Contributing

Issues and PRs are welcome
